interface to the I O subsystem much as system calls provide a standard interface between the application and the operating system Input Output Devices The I O Input Output devices devices can be roughly divided into two categories Block devices and character devices A block device is one that stores information in fixes size blocks each one with its own address Common block sizes range from bytes to bytes The essential property of a block device is that it is possible to read or write each block independently of all the other ones In other words at any instant the program can read or write any of the blocks Disks are block devices If you look closely the boundary between device that are block addressable and those that are not is not well defined Everyone agrees that a disk is a block addressable device because no matter where the arm currently is it is always possible to seek another cylinder and then wait for the required block to rotate under the head Now consider a magnetic tape containing blocks of K bytes If the tape drive is given a command to read block N it always rewind the tape and go forward unti l it comes to block N This operation is analogous to a disk doing seek except that it take much longer Also it may or may not be possible to rewrite one block in the middle of a tape Even if were possible to use magnetic tapes as block devices that ar e stretching the point somewhat they are normally not used that way The other type of I O device is the character device A character device delivers or accepts a stream of character without regard to any block structure It is not addressable and does not have any seek operation Terminals line printers paper tapes punched cards network interface mice for pointing and most other devices that are not disk like can be seen as character devices This classification scheme is not perfect Some dev ices just do not fit in However the model of block and character devices is general enough that it can be used as a basis for making the I O system device independent A typical microcomputer system consists of a microprocessor plus memory and I O interf ace The various components that form the system are linked through buses that transfer instructions data addresses and control information among the components The block diagram of a microcomputer system is shown in Figure 
 Figure Block Dia gram of a Microcomputer System Exercise Check Your Progress Note i Use the space below for your answer Ex Draw the block diagram of block devices and character devices The Input Output Interface The Input output interface provides a method for transferring information between internal storage and external I O devices Peripherals connected to a computer need special communication links for interfacing them with the CPU The purpose of the communication link is to resolve the differences that exist between the central computer a nd each peripheral The major differences are Peripherals are electromagnetic and electromechanical devices and their operations are different from the operation of the CPU and the memory which are electronic devices The data transfer rate of periphera ls is usually slower than the transfer rate of the CPU and consequently a synchronization mechanism may be needed Data codes and formats in peripherals differ from the word format in the CPU and memory The operating modes of peripherals are different from each other and each must be controlled so as not to disturb the operation of other peripherals connected to the CPU The Device Controllers and Its Structure All the components of the computer communicate with the processor through the system b us That means the I O devices need to be attached to the system bus However I O devices are not connected 
 interface called a device controller which in turn is connected to the system bus Hence a device controller is an interface between an I O device and the system bus On one side it knows how to communicate with the I O device connected to it and on the other it knows how to communicate with the Device Controller A device controller need not necessarily control a single device It can usually control multiple I O devices It comes in the form of an electronic circuit board that plugs d irectly into the system bus and there is a cable from the controller to each device it controls The cables coming out of the controller are usually terminated at the back panel of the main computer box in the form of connectors known as ports The Figure illustrates how I O devices are connected to a computer system through device controllers Each I O device is linked through a hardware interface called I O Port Single and Multi port device controls single or multi devices The communication between I O controller and Memory is through bus only in case of Direct Memory Access DMA whereas the path passes through the CPU for such communication in case of non DMA Figure Connecting I O Devices using Device Controller Using device controllers for connecting I O devices to a computer system instead of connecting them directly to the system bus has the following advantages A device controller can be shared among multiple I O devices allowing many I O devices to be connected to the system I O devices can be easily upgraded or changed without any change in the computer system I O devices of manufacturers other than the computer manufacturer can be easily plugged in to the computer system This provides more flexibility to the users in buying I O devices of their choice Structure of an I O Interface Due to the complexity and the number of external devices that the I O interface control there is no standard structure of I O interface Let us give a general structure to an I O interf aces 
 There is a need of I O logic which should interpret and execute dialogue between the processor and I O interface Therefore there need to be control lines between processors and I O interface The data line connecting I O interface to the system bus must exist These lines serve the purpose of data transfer Data registers may act as buffer between processor and I O interface The I O interface contains logic specific to the interface with each device that it controls Caution Do not attempt to resize a partition on a device that is in use it may create data lose Did You Know In Opto created the first generation of digital I O modules with plug in racks for microprocessor based control Hardware Support for I O Computers operate a great many kinds of devices General types include storage devices disks tapes transmission devices network cards modems and human interface devices screen keyboard mouse Other devices are more specialized Consider the ste ering of a military fighter jet or of a space shuttle In these aircraft a human gives input to the flight computer via a joystick and the computer sends output commands that cause motors to move rudders flaps and thrusters Despite the incredible vari ety of I O device that can be used with a computer one needs only a few concepts to understand how the devices are attached and how the software can control the hardware A device communicates with a computer system by sending signals over a cable or eve n through the air The device communicates with the machine via a connection point termed a port for example a serial port If one or more devices use a common set of wires the connection is called a bus In slightly more formal terms a bus is a set o f wires and a rigidly defined protocol that specifies a set of messages that can be sent on the wires In terms of the electronics the messages are conveyed by patterns of electrical voltages that are applied to the wires with defined timings When device A has a cable that plugs into device B and device B has a cable that plugs into device C and device C plugs into a port on the computer this arrangement is called a daisy chain It usually operates as a bus Buses are used widely in computer architectu re Figure shows a typical Personal Computer PC bus structure This Figure shows a Peripheral Component Interconnect PCI bus the common PC system bus that connects the processor memory subsystem to the fast devices and an expansion bus that connects relatively slow devices such as the keyboard and serial and parallel ports In the upper right portion of the figure four disks are connected together on a Small Computer System Interface SCSI bus that is plugged into a SCSI controller A contr oller is a collection of electronics that can operate a port a bus or a device A serial port controller is an example of a simple device controller It is a single chip in the computer that controls the signals on the wires of a serial port By contrast a SCSI bus controller is not simple Because the SCSI protocol is complex the SCSI bus controller is often implemented as a separate circuit board a host adapter that plugs into the computer It typically contains a processor microcode and some priv ate memory to enable it to process the SCSI protocol messages Some devices have their own built in controllers If you look at a disk drive you will see a circuit board attached to one side This board is the disk controller It implements the disk side of the protocol for some kind of connection SCSI for instance 
 Figure A typical PC bus structure It has microcode and a processor to do many tasks such as bad sector mapping pre fetching buffering and caching Because a common type of software fault is a write through an incorrect pointer to an unintended region of memory a memory mapped device register is vulnerable to accidental modification Of course protected memory helps to reduce this risk Figure Device I O port locati ons on PC compatible computers partial Polling The complete protocol for interaction between the host and a controller can be intricate but the basic handshaking notion is simple One explains handshaking by an example Assume that bits are used to coordinate the producer consumer relationship between the controller and the host The controller indicates its state through the busy bit in the status register Recall that to set a bit means to write a into the bit and to dear a bit mean to write a into it The controller sets the busy bit when it is busy working and clears the busy bit when it is ready to accept the next command The host signals its wishes via the command ready bit in the command register The host sets the command read y bit when a command is available for the controller to execute For this example the host writes output through a port coordinating with the Controller by handshaking as follows The host repeatedly reads the busy bit until that bit becomes clear The host sets the write bit in the command register and writes a byte into the data out register The host sets the command ready bit 
 When the controller notices that the command ready bit is set it sets the busy bit The controller reads the command reg ister and sees the write command It reads the data out register to get the byte and does the I O to the device The controller dears the command ready bit clears the error bit in the status register to indicate that the device I O succeeded and clears the busy bit to indicate that it is finished This loop is repeated for each byte In step the host is busy waiting or polling It is in a loop reading the status register over and over until the busy bit becomes clear If the controller and device are fast this method is a reasonable one But if the wait may be long the host should probably switch to another task But then how does the host know when the controller has become idle For some devices the host must service the device quickly or data w ill be lost For instance when data are streaming in on a serial port or from a keyboard the small buffer on the controller will overflow and data will be lost if the host waits too long before returning to read the bytes Interrupts The basic int errupt mechanism works as follows The CPU hardware has a wire called the interrupt request line that the CPU senses after executing every instruction When the CPU detects that a controller has asserted a signal on the interrupt request line the CPU save s a small amount of state such as the current value of the instruction pointer and jumps to the interrupt handler routine at a fixed address in memory The interrupt handler determines the cause of the interrupt performs the necessary processing and exec utes a return from interrupt instruction to return the CPU to the execution state prior to the interrupt That the device controller raises an interrupt by asserting a signal on the interrupt request line the CPU catches the interrupt and dispatches to th e interrupt handler and the handler clears the interrupt by servicing the device Figure summarizes the interrupt driven I O cycle This basic interrupt mechanism enables the CPU to respond to an asynchronous event such as a device controller becoming ready for service In a modern operating system we need more sophisticated interrupt handling features First we need the ability to defer interrupt handling during critical processing Second we need an efficient way to dispatch to the proper interrup t handler for a device without first polling all the devices to see which one raise can distinguish between high and low priority interrupts and can respond with the appropriate degree of urgency Figure Interrupt driven I O cycle 
Table illustrates the design of the interrupt vector for the Intel Pentium Processor The first events which are non maskable are used to signal various error conditions The events from to which are maskable are used for purposes such as device ge nerated interrupts The interrupt mechanism also implements a system of interrupt priority levels This mechanism enables the CPU to defer the handling of low priority interrupts without masking off all interrupts and makes it possible for a high priority interrupt to pre empt the execution of a low priority interrupt A modern operating system interacts with the interrupt mechanism in several ways At boot time the operating system probes the hardware buses to determine what devices are present and inst alls the corresponding interrupt handlers into the interrupt vector Table Intel Pentium processor event vector table During I O interrupts are raised by the various device controllers when they are ready for service These interrupts unify that ou tput has completed or that input data are available or that a failure has been detected The interrupt mechanism is also used to handle a wide variety of exceptions such as dividing by zero accessing a protected or nonexistent memory address or attemp ting to execute a privileged instruction from user mode The events that trigger interrupts have a common property They are occurrences that induce the CPU to execute an urgent self contained routine An operating system has other good uses for an effici ent hardware mechanism that saves a small amount of processor state and then calls a privileged routine in the kernel For example many operating systems use the interrupt mechanism for virtual memory paging A page fault is an exception that raises an i nterrupt The interrupt suspends the current process and jumps to the page fault handler in the kernel This handler saves the state of the process moves the process to the wait queue performs page cache management schedules an I O operation to fetch th e page schedules another process to resume execution and then returns from the interrupt Another example is found in the implementation of system calls A system call is a function that is called by an application to invoke a kernel service Did You Know publicly disclosed in 
 I O Communication Techniques Binary information received from an external device is usually stored in memory for later processing Information transferred from the central computer into an external device originates in the memory unit Data transfer between the central computer and I O devices may be handled in a variety of modes Three techniques are possible for I O operation These are Programmed input output Interrupt driven input output Direct memory access Figure gives an overview of these three techniques Figure Overview of the three Input Output In programmed I O the I O operations are completely controlled by the processor The processor executes a program that initiates directs and terminate an I O operation It requires a little special I O hardware but is quite time consuming for the processor since the processor has to wait for slower I O operations to complete Figure Three techniques of I O 
 Programmed Input Output Programmed input output is a useful I O method for computers where hardw are costs need to be minimized The input or output operation in such cases may involve a Transfer of data from I O device to the processor registers b Transfer of data from processor registers to memory With the programmed I O method the responsibility of the processor is to constantly check the status of the I O device to check whether it is free or it has finished inputting the data Thus this method is very time consuming where the processor wastes a lot of time in checking and verifyi ng the status of an I O device An example of the use of programmed I O to read in a block of data from a peripheral device into memory I O Commands There are four types of I O commands that an I O interface may receive when it is addressed by a processo r Control These commands are device specific and are used to provide specific instructions to the device e g a magnetic tape requiring rewinding and moving forward by a block Test This command checks the status such as if a device is ready or not or is in error condition Read This command is useful for input of data from input device Write this command is used for output of data to output device I O Instructions An I O instruction is stored in the memory of the computer and is fetched and execut ed by the processor producing an I O related command for the I O interface With programmed I O there is a close correspondence between the I O related instructions and the I O commands that the processor issues to an I O interface to execute the instruct ions In systems with programmed I O the I O interface the main memory and the processors normally share the system bus Thus each I O interface should interpret the address lines to determine if the command is for itself There are two methods for doin g so These are called memory mapped I O and isolated I O With memory mapped I O there is a single address space for memory locations and I O devices The processor treats the status and data registers of I O interface as memory locations and uses the sa me machine instructions to access both memory and I O devices For a memory mapped I O only a single read and a single write line are needed for memory or I O interface read or write operations These lines are activated by the processor for either memory access or I O device access With isolated I O there are separate controls lines for both memory and I O device read or write operations Thus a memory reference instruction does not affect an I O device In isolated I O the I O devices and memory are ad dressed separately hence separate input output instructions are needed which cause data transfer between addressed I O interface and processor Interrupt Driven Input Output The problem with programmed I O is that the processor has to wait a long time for the I O interface to see whether a device is free or wait till the completion of I O The result is that the performance of the processor goes down tremendously What is the solution What about the processor going back to do other useful work without waiting for the I O device to complete or get freed up But how will the processor be intimated about the completion of I O or a device is ready for I O A well designed mechanis m was conceived for this which is referred to as interrupt driven I O In this mechanism 
provision of interruption of processor work once the device has finished the I O or when it is ready for the I O has been provided The interrupt driven I O mechan ism for transferring a block of data is shown in Figure Please note that after issuing a read command for input the CPU goes off to do other useful work while I O interface proceeds to read data from the associated device On the completion of an in struction cycle the CPU checks for interrupts which will occur when data is in data register of I O interface and it executing program in a stack and requests th e I O device to provide its data which is placed on the data bus by the I O device After taking the required action with the data the CPU can go back to the program it was executing before the interrupt Interrupt Processing The occurrence of an interrupt fires a numbers of events both in the processor hardware and software When an I O device completes an I O operation the following sequence of hardware events occurs The device issues an interrupt signal to the processor The processor finishe s execution of the current instruction before responding to the interrupt The processor tests for the interrupts and sends an acknowledgement signal to the device that issued the interrupt The minimum information required to be stored for the task being currently executed before the CPU starts executing the interrupt routine using its registers are a The status of the processor which is contained in the register called program status word PSW b The location of the next instruction to be executed of t he currently executing program which is contained in the program counter PC The processor now loads the PC with the entry location of the interrupt handling program that will respond to this interrupting condition Once the PC has been loaded the proc essor proceeds to execute the next instruction that is the next instruction cycle which begins with an instruction fetch Because the instruction fetch is determined by the contents of the PC the result is that control is transferred to the interrupt han dler program The PC and PSW relating to the interrupted program have already been saved on the system stack The contents of the processor registers are also needed to be saved on the stack that is used by the called interrupt servicing routine because th ese registers may be modified by the interrupt handler Here a user program is interrupted after the instruction at location N The contents of all of the registers plus the address of the next instruction N are pushed on to the stack The interrupt ha ndler next processes the interrupt This includes determining of the event that caused the interrupt and also the status information relating to the I O operation When interrupt processing is complete the saved register values are retrieved from the stac k and restored to the registers The final step is to restore the values of PSW and PC from the stack As a result the instruction to be executed will be from the previously interrupted program Thus interrupt handling involves interruption of the curren tly executing program execution of interrupt servicing program and restart of interrupted program from the point of interruption Design issues Two design issues arise in implementing interrupt driven I O How does the processor determine which device issued the interrupt 
 If multiple interrupts have occurred how does the processor decide which one to be processed first To solve these problems four general categories of techniques are in common use Multiple Interrupt Lines The simplest solution to the problems above is to provide multiple interrupt lines which will result in immediate recognition of the interrupting device Priorities can be assigned to various interrupts and the interrupt with the highest priority should be selected for service in case a multiple interrupt occurs But providing multiple interrupt lines is an impractical approach because only a few lines of the system bus can be devoted for the interrupt Software Poll In this scheme on the occurrence of an interrupt the proces sor jumps to an interrupt service program or routine whose job it is to poll roll call each I O interface to determine which I O interface has caused the interrupt This may be achieved by reading the status register of the I O interface Once the correc t interface is identified the processor branches to a device service routine specific to that device The disadvantage of the software poll is that it is time consuming Daisy Chain This scheme provides a hardware poll With this technique an interrupt a cknowledge line is chained through various interrupt devices All I O interfaces share a common interrupt request line When the processor senses an interrupt it sends out an interrupt acknowledgement This signal passes through all the I O devices until it gets to the requesting device The first device which has made the interrupt request thus senses the signal and responds by putting in a word which is normally an address of interrupt servicing program or a unique identifier on the data lines This word is also referred to as interrupt vector This address or identifier in turn is used for selecting an appropriate interrupt servicing program The daisy chaining has an in built priority scheme which is determined by the sequence of devices on interrupt a cknowledge line Bus Arbitration In this scheme the I O interface first needs to control the bus and only after that it can request for an interrupt In this scheme since only one of the interfaces can control the bus therefore only one request can be made at a time The interrupt request is acknowledged by the CPU on response of which I O interface places the interrupt vector on the data lines An interrupt vector normally contains the address of the interrupt serving program An example of an interrup t vector can be a personal computer where there are several IRQs Interrupt request for a specific type of interrupt DMA Direct Memory Access In both interrupt driven and programmed I O the processor is busy with executing input output instruc tions and the I O transfer rate is limited by the speed with which the processor can test and service a device What about a technique that requires minimal intervention of the CPU for input output These two types of drawbacks can be overcome with a more efficient technique known as DMA which acts as if it has taken over control from the processor Hence the question is why do we use DMA interface It is used primarily when a large amount of data is to be transferred from the I O device to the Memory D MA Function Although the CPU intervention in DMA is minimized yet it must use the path between interfaces that is the system bus Thus DMA involves an additional interface on the system bus A technique called cycle stealing allows the DMA interface to t ransfer one data word at a time after which it must return control of the bus to the processor The processor merely delays its operation for one memory cycle the 
processor issues a command to the DMA interface by sending to the DMA interface the following information Which operations read or write to be performed using the read or write control lines The address of I O devices which is to be used communi cated on the data lines The starting location on the memory where the information will be read or written to be communicated on the data lines and is stored by the DMA interface in its address register The number of words to be read or written is communi cated on the data lines and is stored in the data count register Figure DMA block diagram The DMA interface transfers the entire block of data one word at a time directly to or from memory without going through the processor When the transfer is complete the DMA interface sends an interrupt signal to the processor Thus in DMA the processor involvement can be restricted at the beginning and end of the transfer The DMA mechanism can be configured into a variety of ways In which all interfac es share the same system bus The DMA acts as the supportive processor and can use programmed I O for exchanging data between memory and I O interface through DMA interface But once again this spoils the basic advantage of DMA not using extra cycles for t ransferring information from memory to from DMA and DMA from to I O interface The configuration suggests advantages over the one In these systems a path is provided between I O interface and DMA interface which does not include the system bus The DMA l ogic may become part of an I O interface and can control one or more I O interfaces In an extended concept an I O bus can be connected to this DMA interface Such a configuration is quite flexible and can be extended very easily In both these configurati ons the added advantage is that the data between I O interface and DMA interface is transferred off the system bus thus eliminating the disadvantage we have witnessed for the first configuration Exercise Check Your Progress Note i Use the space below for your answer Ex Make a list of I O of operation in a system 
 I O Software Device Drivers A device driver is a program routine that links a peripheral device to an operating system of a computer It is essentially a software program that allows a user to employ a device such as a printer monitor or mouse It is written by programmers who com prehend the detailed knowledge of the to perform the functions requested by the application When a new hardware device is added to the computer such as a C D ROM drive a printer or a sound card its driver must be installed in order to example everything that is seen on the screen is the result of the displ ay driver video driver The display driver effectuates the visual appearance of the screen according to the precise commands that Windows issues to it The driver is the link between the operating system and the peripheral device If the peripheral devi ce is changed or if a bug is found in the driver the driver must also be changed A new version of the driver is then written and released by the manufacturer of the device The basic input output I O hardware features such as ports buses and device controllers accommodate a wide variety of I O devices To encapsulate the details and unique features of different devices the kernel of an operating system is set up to use device driver modules The device drivers present a uniform device access inter face to the I O subsystem Each of the different types of I O devices is accessed through a standardized set of functions an interface The tangible differences are encapsulated in kernel modules i e device drivers that internally are customized for ea ch device but that export and utilize one of the standard interfaces A device driver sets the direct memory access DMA control registers to use appropriate source and destination addresses and transfer length The DMA controller is then instructed to begin the I O operation Refer to Figure to see how a device driver a mouse driver in this example relates to the structure of the operating system Figure Mouse and mouse device driver in a kernel input output structure of an operating system Device drivers are saved as files and are called upon when a particular peripheral or hardware device is needed On the Macintosh for instance they are stored in the extensions folder like extensions their features are preset and cannot be modified Once they are installed the devices they control become available for use To provide an efficient and convenient access to the hard disk the operating system requires the file system to allow the data to be stored located and retrieved easil y The file system is composed of several different levels The lowest level see Figure is the input output I O control and 
consists of device drivers and interrupt handlers to transfer information between the memory and the hard disk A device d river is the basically a translator It is input consists of high level commands and it is output consists of low level hardware specific instructions which are utilized by the hardware controller which interfaces the I O device to the rest of the oper ating system The device the controller know on which device location to act and what subsequent actions to provide Figure Layered file syst em of a computer Caution There are no user level file permissions All file locations specified by the UTL FILE DIR parameters are valid for both reading and writing for all users of the file I O procedures This can override operating system file perm issions Self Assessment Questions interface units communicates with various external devices through the I O Bus a multiple b single c Both a and b d None of these devices a internal storage b external storage c virtual storage d cash memory es a electromagnetic b paramagnetic c diamagnetic d All of these An I O interface is bridge between the processor and I O devices It controls the data exchange a main memory b external device c processor registers d All of these 
 Programmed input output is not a useful I O method for computers where hardware costs need to be minimized a True b False a Control b Read c Write d All of these Performance Consideration The Performance Consideration presents a number of considerations regarding implementation of Linux based solutions on System platform The information presented in this appendix is not intended to be the definitive word on performance and will not present specific performance characteristics of a given workload As with anything involving performance it is recommended that plan on prototyping solutions and be prepared to make changes as you go f orward The information presented in this appendix can be broken down into three broad categories Virtual I O support One of the key strengths to implementing Linux based solutions on the System platform is the ability to have the I O disk hosted by an OS partition and thereby extend the benefits of single level store to the Linux operating system We will considerations regarding performance as well as changes that have occurred in recent versions of OS that you should be aware of Virtual network su pport Another advantage of implementing Linux based solutions on the System platform is the ability to build virtual Ethernet networks LANs inside the managed system that is with no physical hardware The importance of the frame sizes of the network adapters as well as when it may be advantageous to implement multiple virtual LANs Processor considerations The System platform supports the ability to share processors between multiple logical partitions LPARs and to have the firmware hypervisor bal ance workload across the available processors through the uncapped partition support Did You Know Intel Corporation started the work on Peripheral Component Interconnect or PCI in On June PCI was introduced in the computer world Exercise Check Your Progress Case Study I O bound Multiuser System A multiuser system in a company serves approximately employees running a variety of packages including a simple database application non relational an accounting package and word processing software At peak usage there are complaints from users that response is slow and that characters are echoed with a noticeable time delay System configuration The system configuration is Uniprocessor DX running at MHz EISA bus MB of RAM MB of swap space NBUF set to 
 Two GB SCSI hard disks One port and one port non intelligent serial card using UARTs ASCII terminals and PCs running terminal emulation software One V fax modem Defining a Performa nce Goal The system administrator is tasked with improving the interactive performance of the system Funds to the system must be undertaken with minimal di sruption to the users Collecting Data The administrator ensures that system accounting is enabled using sar enable ADM and produces reports of system activity at five minute intervals during the working week by placing the following crontab C file usr lib sa sa s e i A The administrator notes the times at which users report that the system response is slow and examines the corresponding operating system activity in the report effectivel y using sar u usr sys wio idle The system is spending a large amo unt of time in system mode and little time idle or waiting for I O The length of the run queue shows that an unacceptably large number of user processes are lined up for running sar q statistics runq sz runocc swpq sz swpocc An acceptable number of processes on the run queue would be two or fewer At times when the system response seems acceptable the system activity has the following patter n usr sys wio idle This shows that the system spends little time wa iting for I O and a large proportion of time in user mode The idle figure shows more than spare CPU capacity on the system The run queue statistics also show that user processes are getting fair access to run on the CPU runq sz runocc swpq sz swpocc Formulating a Hypothesis From the CPU utilization statistics it looks as though the system is occasionally spending too much time in system mode This could be caused by memory shortages or too much overhead placed on the CPU by peripheral devices The low waiting on I O figures imply that memory shortage is not a 
problem If the system were swapping or paging this would usually generate much more disk activity The administrator next examines the performance of the memory disk and serial I O subsystems to check on their perform ance Getting More Specifics The memory usage figures for the period when the proportion of time spent in system mode sys was high show the following pattern sar r statistics freemem freeswp The value of GPGSHI for this system is and none of the swap space is allocated to processes there is no apparent evidence of swapping or paging to disk This is confirmed by examining the reports f or sar w swpin s bswin s swpot s bswot s pswch s The zero values for swpot s and bswot s indicate that there was no swapping out activity Examining the sar q sar r and sar w reports at other times shows occasional short periods of paging activity but these are correlated with batch p ayroll runs It should be possible to reduce the impact of these on the system by rescheduling the jobs to run overnight The administrator next examines the buffer cache usage statistics for the same period sar b statistics bread s lread s r cache bwrit s lwrit s wcache pread s pwrit s These figures show hit rates on the buffer cache of about for reads and for writes Approximately KB of data bread s bwrit s is being read from or written to disk per second Disk performance is examined next using the statistics provided by sar d device busy avque r w s blks s avwait avserv Sdsk Sdsk Sdsk Sdsk Sdsk Sdsk Sdsk Sdsk These results show that the busiest disk Sdsk has acceptable performanc e with a reasonably short request queue acceptable busy values and low wait and service times The pattern of activity on the root disk Sdsk is such that the request queue is longer since requests are tending to arrive in 
bursts There is no evidence that the system is disk I O bound though it may be possible to improve the interactive performance of some applications by increasing the buffer cache hit rates Making Adjustments to the System Based on the evidence given above the system would benefit from increasing the number of buffers in the buffer cache Although the system does not show much sign of being disk I O bound sar u shows wio less than at peak load applications are placing a reasonably heavy demand on the second SCSI disk Sdsk This will affect the interactive response of programs which have to sleep if the data being requested cannot be found in the buffer cache As the system does not appear to be short of memory at peak load the system administrator may wish to experimen t with doubling the size of the buffer cache by setting NBUF to Based on the evidence from sar r that approximately MB KB pages of memory are free at peak load doubling the size of the buffer cache will reduce this value to about MB If t he size of the buffer cache is increased the system should be monitored to see If the proportion of time spent waiting for I O decreases wio reported by sar u If the buffer cache hit rates improve rcache and wcache reported by sar b If disk acti vity on the second SCSI disk decreases appreciably as a result of increasing the number of buffers busy reported by sar d If the system is becoming short of memory sar r reports that freemem is dropping near to or below the value of GPGSHI If incre asing the size of the buffer cache starts to make the system swap or page out intensively the administrator should either reduce its size again or make more memory available in other ways If the interactive performance of applications is still less than desired another possibility is to use intelligent serial I O cards to relieve the processing overhead on the CPU The serial multiport cards use UARTs and were previously used in two less powerful systems It is possible that the CPU is spending too much time moving characters out to the serial lines on behalf of the serial cards The CPU will do this whenever the applications need to refresh terminal screens to update database forms word processor displays and so on Questions What is the Multiuse r System What is the idle figure in I O bound multiuser system Summary The Input Output interface provides a method for transferring information between internal storage and external I O devices The Input Output subsystem of a computer referred to as I O provides an efficient mode of communication between the central system and the output environment A device driver is a program routine that links a peripheral device to an operating system of a computer It is essentially a software program th at allows a user to employ a device such as a printer monitor or mouse An I O instruction is stored in the memory of the computer and is fetched and executed by the processor producing an I O related command for the I O interface Data buffering is qui te useful for the purpose of smoothing out the gaps in speed of processor and the I O devices The data buffers are registers which hold the I O information temporarily 